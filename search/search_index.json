{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Visual Layout Api layout ( 100 , |- email -| ~ 80 , 8 , |- password - forgot -| ~ 80 , = 20 , | login | ~ 80 , 0 ) Chainable Api email . top ( 100 ). left ( 8 ). right ( 8 ). width ( 200 ). height ( 44 ) alignHorizontally ( password , forgot ) image . fillContainer () button . centerInContainer (). size ( 50 % ) equalWidths ( email , password ) image . width ( = 80 ) Equation-Based Api email . Top == 100 password . CenterY == forgot . CenterY login . Top = password . Bottom + 20 login . Width == 75 % Width All Generate native NSLayoutConstraints \ud83c\udf89 Try it! Stevia is part of freshOS iOS toolset. Try it in an example App ! Download Starter Project Reason Why Because nothing holds more truth than pure code \ud83e\udd13 Xibs and storyboards are heavy, hard to maintain, hard to merge. They split the view concept into 2 separate files making debugging a nightmare There must be a better way How By creating a tool that makes Auto layout code finally readable by a human being . By coupling it with live code injection such as injectionForXcode we can design views in real time View layout becomes fun , concise , maintainable and dare I say, beautiful \u2764\ufe0f What [x] Pure Swift Auto Layout DSL. [x] Simple: the apis are just NSLayoutConstraint shortcuts, pure UIKit code, no voodoo magic. Advantages of Stevia [x] Improves the readability of Auto Layout in code. [x] Concise yet flexible apis. [x] Type-Safe Visual Format language. [x] Decribe Horizontal vertical layout at the same time. [x] Supports Live reload, for faster iteration cycles. [x] Styling is more concise, reusable and can be composed. Login View Example In the project folder, you can find an example of a typical login view laid out in both native and Stevia for you to understand and compare the two approaches. As a spoiler alert, the number of characters goes from 2380 to 1239 ( ~ divided by 2) Write Half the code that is actually 10X more expressive and maintainable ! Contributors YannickDot , S4cha , Damien , Snowcraft , Mathieu-o Swift Version Swift 2 - version 2.3.0 Swift 3 - version 3.2.0 Swift 4 - version 4.0.0 Backers Like the project? Offer coffee or support us with a monthly donation and help us continue our activities :) Sponsors Become a sponsor and get your logo on our README on Github with a link to your site :)","title":"Overview"},{"location":"#visual-layout-api","text":"layout ( 100 , |- email -| ~ 80 , 8 , |- password - forgot -| ~ 80 , = 20 , | login | ~ 80 , 0 )","title":"Visual Layout Api"},{"location":"#chainable-api","text":"email . top ( 100 ). left ( 8 ). right ( 8 ). width ( 200 ). height ( 44 ) alignHorizontally ( password , forgot ) image . fillContainer () button . centerInContainer (). size ( 50 % ) equalWidths ( email , password ) image . width ( = 80 )","title":"Chainable Api"},{"location":"#equation-based-api","text":"email . Top == 100 password . CenterY == forgot . CenterY login . Top = password . Bottom + 20 login . Width == 75 % Width All Generate native NSLayoutConstraints \ud83c\udf89","title":"Equation-Based Api"},{"location":"#try-it","text":"Stevia is part of freshOS iOS toolset. Try it in an example App ! Download Starter Project","title":"Try it!"},{"location":"#reason","text":"","title":"Reason"},{"location":"#why","text":"Because nothing holds more truth than pure code \ud83e\udd13 Xibs and storyboards are heavy, hard to maintain, hard to merge. They split the view concept into 2 separate files making debugging a nightmare There must be a better way","title":"Why"},{"location":"#how","text":"By creating a tool that makes Auto layout code finally readable by a human being . By coupling it with live code injection such as injectionForXcode we can design views in real time View layout becomes fun , concise , maintainable and dare I say, beautiful \u2764\ufe0f","title":"How"},{"location":"#what","text":"[x] Pure Swift Auto Layout DSL. [x] Simple: the apis are just NSLayoutConstraint shortcuts, pure UIKit code, no voodoo magic.","title":"What"},{"location":"#advantages-of-stevia","text":"[x] Improves the readability of Auto Layout in code. [x] Concise yet flexible apis. [x] Type-Safe Visual Format language. [x] Decribe Horizontal vertical layout at the same time. [x] Supports Live reload, for faster iteration cycles. [x] Styling is more concise, reusable and can be composed.","title":"Advantages of Stevia"},{"location":"#login-view-example","text":"In the project folder, you can find an example of a typical login view laid out in both native and Stevia for you to understand and compare the two approaches. As a spoiler alert, the number of characters goes from 2380 to 1239 ( ~ divided by 2) Write Half the code that is actually 10X more expressive and maintainable !","title":"Login View Example"},{"location":"#contributors","text":"YannickDot , S4cha , Damien , Snowcraft , Mathieu-o","title":"Contributors"},{"location":"#swift-version","text":"Swift 2 - version 2.3.0 Swift 3 - version 3.2.0 Swift 4 - version 4.0.0","title":"Swift Version"},{"location":"#backers","text":"Like the project? Offer coffee or support us with a monthly donation and help us continue our activities :)","title":"Backers"},{"location":"#sponsors","text":"Become a sponsor and get your logo on our README on Github with a link to your site :)","title":"Sponsors"},{"location":"cells/","text":"For both tableView cells and UICollectionView cells, sv adds the subviews to the contentView , as recommended. Example class FriendCell : UITableViewCell { let avatar = UIImageView () let name = UILabel () required init ?( coder aDecoder : NSCoder ) { super . init ( coder : aDecoder )} override init ( style : UITableViewCellStyle , reuseIdentifier : String ?) { super . init ( style : style , reuseIdentifier : reuseIdentifier ) sv ( avatar , name . style ( nameStyle ) ) avatar . size ( 50 ). centerVertically () alignHorizontally ( |- 20 - avatar - name - 20 -| ) } func nameStyle ( l : UILabel ) { l . font = . systemFontOfSize ( 24 ) l . textColor = . blueColor () } } Then in the viewController you do the usual register and dequeue :) // In viewDidLoad, register your cell for dequeue tableView . registerClass ( FriendCell . self , forCellReuseIdentifier : FriendCell ) // Later, in cellForRowAtIndexPath let cell = tableView . dequeueReusableCellWithIdentifier ( FriendCell , forIndexPath : indexPath ) as ! FriendCell","title":"TableView Cells & CollectionView Cells"},{"location":"cells/#example","text":"class FriendCell : UITableViewCell { let avatar = UIImageView () let name = UILabel () required init ?( coder aDecoder : NSCoder ) { super . init ( coder : aDecoder )} override init ( style : UITableViewCellStyle , reuseIdentifier : String ?) { super . init ( style : style , reuseIdentifier : reuseIdentifier ) sv ( avatar , name . style ( nameStyle ) ) avatar . size ( 50 ). centerVertically () alignHorizontally ( |- 20 - avatar - name - 20 -| ) } func nameStyle ( l : UILabel ) { l . font = . systemFontOfSize ( 24 ) l . textColor = . blueColor () } } Then in the viewController you do the usual register and dequeue :) // In viewDidLoad, register your cell for dequeue tableView . registerClass ( FriendCell . self , forCellReuseIdentifier : FriendCell ) // Later, in cellForRowAtIndexPath let cell = tableView . dequeueReusableCellWithIdentifier ( FriendCell , forIndexPath : indexPath ) as ! FriendCell","title":"Example"},{"location":"changingConstraints/","text":"After laying out a view once, how do I change some constraints ? Simple Changes // Initial layout image . height ( 100 ) // And later on image . heightConstraint ?. constant = 200 Those getters are available for left , right , top , bottom , height and width constraints Complex changes When we want to change the whole layout at once then the best strategy is to flush relayout. // Initial layout layout ( 100 , |- email -| , 8 , |- password -| , ) // Creating an extension for getting user added constraints extension UIView { var userAddedConstraints : [ NSLayoutConstraint ] { return constraints . filter { c in guard let cId = c . identifier else { return true } return ! cId . contains ( UIView-Encapsulated-Layout ) } } } // remove userAddedConstraints removeConstraints ( userAddedConstraints ) // Re-apply different layout layout ( |- password -| , 8 , |- 44 - email - 100 -| , 10 ) Animating Changes To animate a constraint is to change the constant property on it and then call self.layoutIfNeeded() in an animation block. Animating with stevia is no different than native Autolayout In both cases, animating the constraint change is as easy as calling layoutIfNeeded in an animation block. UIView . animateWithDuration ( 2 ) { self . layoutIfNeeded () }","title":"Changing Constraints"},{"location":"changingConstraints/#simple-changes","text":"// Initial layout image . height ( 100 ) // And later on image . heightConstraint ?. constant = 200 Those getters are available for left , right , top , bottom , height and width constraints","title":"Simple Changes"},{"location":"changingConstraints/#complex-changes","text":"When we want to change the whole layout at once then the best strategy is to flush relayout. // Initial layout layout ( 100 , |- email -| , 8 , |- password -| , ) // Creating an extension for getting user added constraints extension UIView { var userAddedConstraints : [ NSLayoutConstraint ] { return constraints . filter { c in guard let cId = c . identifier else { return true } return ! cId . contains ( UIView-Encapsulated-Layout ) } } } // remove userAddedConstraints removeConstraints ( userAddedConstraints ) // Re-apply different layout layout ( |- password -| , 8 , |- 44 - email - 100 -| , 10 )","title":"Complex changes"},{"location":"changingConstraints/#animating-changes","text":"To animate a constraint is to change the constant property on it and then call self.layoutIfNeeded() in an animation block. Animating with stevia is no different than native Autolayout In both cases, animating the constraint change is as easy as calling layoutIfNeeded in an animation block. UIView . animateWithDuration ( 2 ) { self . layoutIfNeeded () }","title":"Animating Changes"},{"location":"installation/","text":"Installation CocoaPods pod SteviaLayout use_frameworks ! Carthage github freshOS/Stevia Create a Cartfile file at the root of your project folder Add github \"freshOS/Stevia\" to your Cartfile Run carthage update Drag and drop Stevia.framework from /Carthage/Build/iOS/ to Linked frameworks and libraries in Xcode (Project Target General Linked frameworks and libraries) Add new run script (Project Target Build Phases + New run script phase) /usr/local/bin/carthage copy-frameworks Add Input files $(SRCROOT)/Carthage/Build/iOS/Stevia.framework There you go! Manual Copy Stevia source files to your Xcode project","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#cocoapods","text":"pod SteviaLayout use_frameworks !","title":"CocoaPods"},{"location":"installation/#carthage","text":"github freshOS/Stevia Create a Cartfile file at the root of your project folder Add github \"freshOS/Stevia\" to your Cartfile Run carthage update Drag and drop Stevia.framework from /Carthage/Build/iOS/ to Linked frameworks and libraries in Xcode (Project Target General Linked frameworks and libraries) Add new run script (Project Target Build Phases + New run script phase) /usr/local/bin/carthage copy-frameworks Add Input files $(SRCROOT)/Carthage/Build/iOS/Stevia.framework There you go!","title":"Carthage"},{"location":"installation/#manual","text":"Copy Stevia source files to your Xcode project","title":"Manual"},{"location":"knownIssues/","text":"Expression was to complex to be solved in reasonable time \"Expression was to complex to be solved in reasonable time\" can happen in Stevia, since the swift compiler has a hard time finding the right - operator overload. However it usually only happens with very long horizontal layouts with multiple margins. Here are three valid solutions for avoiding this annoying compiler error. All of them aim at making it easier for the compiler to find the right - operator version. // Solution 1 // Putting margins in separate variables let m : CGFloat = 15 let m2 : CGFloat = 20 |- m - avatarImageView - m - userNameLabel - - likeButton - m2 -| // Or Provide the type for margins to help the compiler |- CGFloat ( 15 ) - avatarImageView - CGFloat ( 15 ) - userNameLabel - - likeButton - CGFloat ( 20 ) -| // Solution 2 // Breaking it into smaller layouts |- 15 - avatarImageView - 15 - userNameLabel likeButton - 20 -| // Solution 3 // Using a double dash `--` version so that the compiler doesn t have to go through // all the existing `-` operator overloads defined by UIKit/Foundation |- 15 -- avatarImageView -- 15 -- userNameLabel -- -- likeButton -- 20 -|","title":"Known Issues"},{"location":"knownIssues/#expression-was-to-complex-to-be-solved-in-reasonable-time","text":"\"Expression was to complex to be solved in reasonable time\" can happen in Stevia, since the swift compiler has a hard time finding the right - operator overload. However it usually only happens with very long horizontal layouts with multiple margins. Here are three valid solutions for avoiding this annoying compiler error. All of them aim at making it easier for the compiler to find the right - operator version. // Solution 1 // Putting margins in separate variables let m : CGFloat = 15 let m2 : CGFloat = 20 |- m - avatarImageView - m - userNameLabel - - likeButton - m2 -| // Or Provide the type for margins to help the compiler |- CGFloat ( 15 ) - avatarImageView - CGFloat ( 15 ) - userNameLabel - - likeButton - CGFloat ( 20 ) -| // Solution 2 // Breaking it into smaller layouts |- 15 - avatarImageView - 15 - userNameLabel likeButton - 20 -| // Solution 3 // Using a double dash `--` version so that the compiler doesn t have to go through // all the existing `-` operator overloads defined by UIKit/Foundation |- 15 -- avatarImageView -- 15 -- userNameLabel -- -- likeButton -- 20 -|","title":"Expression was to complex to be solved in reasonable time"},{"location":"liveReload/","text":"Live Reload You can even enable live reload during your development phase! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Stevia + InjectionForXcode = 3 (WhoNeedsReactNative??) \ud83d\ude80 Just Cmd+S and you can dev live in the simulator ! Download InjectionForXcode on the Appstore Install it Launch it. Choose Open Project and choose your project's root folder. Make sure on File Watcher is selected that Cmd+S triggers an injection. In your AppDelegate , put the following snippet to load injection on App start. Make sure to remove this for release builds :) Bundle ( path : /Applications/InjectionIII.app/Contents/Resources/iOSInjection10.bundle )?. load () In order to support live reload with InjectionForXcode, we simply need to tell our ViewController to rebuild a view after an injection occured. in viewDidLoad() add : on ( INJECTION_BUNDLE_NOTIFICATION ) { self . view = MyView () } And Voila :)","title":"Live Reload"},{"location":"liveReload/#live-reload","text":"You can even enable live reload during your development phase! \ud83c\udf89\ud83c\udf89\ud83c\udf89 Stevia + InjectionForXcode = 3 (WhoNeedsReactNative??) \ud83d\ude80 Just Cmd+S and you can dev live in the simulator ! Download InjectionForXcode on the Appstore Install it Launch it. Choose Open Project and choose your project's root folder. Make sure on File Watcher is selected that Cmd+S triggers an injection. In your AppDelegate , put the following snippet to load injection on App start. Make sure to remove this for release builds :) Bundle ( path : /Applications/InjectionIII.app/Contents/Resources/iOSInjection10.bundle )?. load () In order to support live reload with InjectionForXcode, we simply need to tell our ViewController to rebuild a view after an injection occured. in viewDidLoad() add : on ( INJECTION_BUNDLE_NOTIFICATION ) { self . view = MyView () } And Voila :)","title":"Live Reload"},{"location":"nested/","text":"We believe complex nested views should be refactored into their own UIView subclasses. For instance, if out App is using a form field multiple times, it is wise to extract it in its own UIView subclass like so: class CustomField : UIView { let icon = UIImageView () let field = UITextField () let image = UIImageView () convenience init () { self . init ( frame : CGRect . zero ) sv ( icon , field , image ) alignHorizontally ( |- icon . size ( 40 ). centerVertically () - field - image . size ( 40 ) -| ) backgroundColor = . whiteColor () layer . cornerRadius = 5 layer . shadowOffset = CGSize ( width : 2 , height : 2 ) layer . shadowOpacity = 0.5 icon . backgroundColor = . grayColor () image . backgroundColor = . blackColor () } } And then we can use it easily like so whenever we need it: class LoginView : UIView { let usernameField = CustomField () let passwordField = CustomField ()","title":"Complex nested layout"},{"location":"styling/","text":"Well, just call style on a UIView subclass : In-line for small or unique styles detail . style { l in l . numberOfLines = 0 l . textAlignment = . Center l . textColor = . blueColor () l . text = NSLocalizedString ( NeedPetMessage , comment : ) } Or in a separate to make them reusable // My style method, kinda like CSS func detailStyle ( l : UILabel ) { l . numberOfLines = 0 l . textAlignment = . Center l . textColor = . blueColor () l . text = NSLocalizedString ( NeedPetMessage , comment : ) } // Later { // Set my style detail . style ( detailStyle ) } This is the preferred way because the styles become reusable and composable : you can chain them! You can even create a Style File grouping high level functions for common styles. Usage then becomes very similar to CSS!","title":"Styling"},{"location":"viewFromController/","text":"Once again, this is not Stevia-related per se but since we're not generally used to writing views in code, then some explanation might be useful \ud83e\udd13 It goes like this : - 1. Keeping a reference to our custom view. - 2. Loading our view instead of the bare default one by overriding loadView class MyViewController : UIViewController { let myCustomView = MyCustomView () // 1 override func loadView () { // 2 view = myCustomView } override func viewDidLoad () { super . viewDidLoad () myCustomView . loginButton . addTarget ( self , action : #selector ( login ), for : . touchUpInside ) } @objc func login () { // do something } }","title":"Getting views from the controller"},{"location":"viewHierarchy/","text":"sv ( subview1 , subview2 , subview3 ) sv([]) and sv() are essentially shortcuts that call addSubview() and view.translatesAutoresizingMaskIntoConstraints = false It also has the benefit of being very visual so that your can actually see what the view hierarchy is. This is especially true for nested hierarchies : sv ( subview1 , subview2 . sv ( nestedView1 , nestedView2 \u0328 ), subview3 )","title":"View Hierarchy"},{"location":"layout/aligning/","text":"Horizontally alignHorizontally ( avatar , name , followButton ) Vertically alignVertically ( title , subtitle , text ) Tops alignTops ( title , subtitle , text ) Bottoms alignBottoms ( title , subtitle , text ) Rights alignRights ( title , subtitle , text ) Lefts alignLefts ( title , subtitle , text ) Align the center of one view with another one : alignCenter ( view1 , with : view2 ) In the example above of a follow Cell, here is how the layout code would look like : |- avatar - 15 - name - 20 - followButton -| alignHorizontally ( avatar , name , followButton ) But |-avatar-15-name-20-followButton-| actually returns the array of views!!! so we can write it in one single statement : alignHorizontally ( |- avatar - 15 - name - 20 - followButton -| ) Baselines align ( lastBaselines : label , label2 , label3 ) label . LastBaseline == label . LastBaseline + 24 \ud83c\udf89\ud83c\udf89\ud83c\udf89","title":"Aligning"},{"location":"layout/centering/","text":"Horizontally imageView . centerHorizontally () imageView . centerHorizontally ( 20 ) //offset Vertically imageView . centerVertically () imageView . centerVertically ( 20 ) //offset On both axis imageView . centerInContainer ()","title":"Centering"},{"location":"layout/equations/","text":"Tricky layout cases can be described as equations. button . CenterY == avatar . Bottom - 4 label . Width = button . Width * 3 label . Height == ( button . Width / 7 ) + 3 button . Left = image . Right - 20 image . Height = 100 view . Top == 10 The result is a native NSLayoutConstraint. So you can modify priority like so : ( label . Width == button . Width * 3 ). priority = 1000 // Making this a required constraint.","title":"Equations"},{"location":"layout/filling/","text":"Horizontally view . fillHorizontally () view . fillHorizontally ( m : 20 ) // padding Vertically view . fillVertically () view . fillVertically ( m : 20 ) // padding All container view . fillContainer () view . fillContainer ( 20 ) // Padding","title":"Filling"},{"location":"layout/flexibleMargins/","text":"Flexible margins can be used exactly like regular margins: With chainable Api view . top ( = 5 ) view . left ( = 20 ) view . bottom ( = 10 ) view . right ( = 15 ) view . width ( = 45 ) view . height ( = 100 ) In layout calls layout ( 5 , |- label - ( = 5 ) -| , = 20 , separator ~ ( = 10 ), 0 )","title":"Flexible"},{"location":"layout/flexibleMargins/#with-chainable-api","text":"view . top ( = 5 ) view . left ( = 20 ) view . bottom ( = 10 ) view . right ( = 15 ) view . width ( = 45 ) view . height ( = 100 )","title":"With chainable Api"},{"location":"layout/flexibleMargins/#in-layout-calls","text":"layout ( 5 , |- label - ( = 5 ) -| , = 20 , separator ~ ( = 10 ), 0 )","title":"In layout calls"},{"location":"layout/following/","text":"The typical example of this is when we want to have a button on top of an image. button . followEdges ( imageView )","title":"Following another View"},{"location":"layout/horizontal/","text":"This is intended to look like Apple's visual format , so you should be very familiar with the syntax. Stevia only removes the [] and the String. Stick a label to the left of the screen | label With the default margin (8) |- label With a custom margin |- 42 - label Just to be very clear we want to emphasize that this is pure syntactic sugar . This equivalent of the following using the chainable api : label . left ( 42 ) Which in turn will create Native Autolayout constraints : label . superview ?. addConstraint ( NSLayoutConstraint ( item : label , attribute :. Left , relatedBy : . Equal , toItem : label . superview !, attribute :. Left , multiplier : 1 , constant : 42 ) ) Combine all at once. |- avatar - 15 - name - 20 - followButton -|","title":"Horizontal"},{"location":"layout/percentage/","text":"view . top ( 5 % ) view . left ( 20 % ) view . bottom ( 10 % ) view . right ( 15 % ) view . width ( 45 % ) view . height ( 100 % ) view . Height == 47 % button . Width","title":"Percentage"},{"location":"layout/priorities/","text":"There is no special Stevia api for priorities. In order to set them, you need to use the good'ol standard api :) By default, Stevia constraints are created with a priority of 751 . let c = NSLayoutConstraint ( item : v , attribute : . Top , relatedBy : . Equal , toItem : v , attribute : . Top , multiplier : 1 , constant : 0 ) c . priority = 1000 // Make a constraint `required` addConstraint ( c ) ( label . Width == button . Width * 3 ). priority = 1000 // Making this a required constraint. let constraint == view . Height = 50 % Height // later.. constraint . priority = 750","title":"Priorities"},{"location":"layout/sizing/","text":"Width view . width ( 100 ) Height view . height ( 100 ) view ~ (100) is same with view.height(100) You can use ~ operator for .height(x) . It's just more readable in a layout statement that way. Size view . size ( 100 ) Constraining multiple views equalSizes ( image1 , image2 , image2 ) equalWidths ( field1 , field2 , field3 , field4 ) equalHeights ( button1 , button2 ) Constraining a view to stay squared view . heightEqualsWidth ()","title":"Sizing"},{"location":"layout/vertical/","text":"avatar . top ( 50 ) == layout ( 50 , avatar ) While using layout for a single element might seem a bit overkill, it really shines when combined with horizontal layout. Then we have the full layout in one place (hence the name). layout ( 50 , |- 15 - avatar . size ( 60 ) ) The avatar is 50px from the top with a left margin of 15px and a size of 60px Another great example is the login view, representable in one single statement ! layout ( 100 , |- email -| ~ 80 , 8 , |- password -| ~ 80 , , | login | ~ 80 , 0 ) Chainable Api The avatar example above could've been written that way using the chainable api : avatar . top ( 50 ). left ( 15 ). size ( 50 ) Using layout is just clearer in most of the cases but it's yours to choose which way you prefer :)","title":"Vertical"},{"location":"layout/vertical/#chainable-api","text":"The avatar example above could've been written that way using the chainable api : avatar . top ( 50 ). left ( 15 ). size ( 50 ) Using layout is just clearer in most of the cases but it's yours to choose which way you prefer :)","title":"Chainable Api"}]}