{
    "docs": [
        {
            "location": "/", 
            "text": "Visual Layout Api\n\n\nlayout\n(\n\n    \n100\n,\n\n    \n|-\nemail\n-|\n \n~\n \n80\n,\n\n    \n8\n,\n\n    \n|-\npassword\n-\nforgot\n-|\n \n~\n \n80\n,\n\n    \n=\n20\n,\n\n    \n|\nlogin\n|\n \n~\n \n80\n,\n\n    \n0\n\n\n)\n\n\n\n\n\n\nChainable Api\n\n\nemail\n.\ntop\n(\n100\n).\nleft\n(\n8\n).\nright\n(\n8\n).\nwidth\n(\n200\n).\nheight\n(\n44\n)\n\n\nalignHorizontally\n(\npassword\n,\n \nforgot\n)\n\n\nimage\n.\nfillContainer\n()\n\n\nbutton\n.\ncenterInContainer\n().\nsize\n(\n50\n%\n)\n\n\nequalWidths\n(\nemail\n,\n \npassword\n)\n\n\nimage\n.\nwidth\n(\n=\n80\n)\n\n\n\n\n\n\nEquation-Based Api\n\n\nemail\n.\nTop\n \n==\n \n100\n\n\npassword\n.\nCenterY\n \n==\n \nforgot\n.\nCenterY\n\n\nlogin\n.\nTop\n \n=\n \npassword\n.\nBottom\n \n+\n \n20\n\n\nlogin\n.\nWidth\n \n==\n \n75\n \n%\n \nWidth\n\n\n\n\n\n\nAll Generate \nnative\n NSLayoutConstraints \ud83c\udf89\n\n\nTry it!\n\n\nStevia is part of \nfreshOS\n iOS toolset. Try it in an example App ! \nDownload Starter Project\n\n\nReason\n\n\nWhy\n\n\nBecause \nnothing holds more truth than pure code\n \ud83e\udd13\n\nXibs and storyboards are \nheavy, hard to maintain, hard to merge.\n\nThey split the view concept into 2 separate files making debugging a \nnightmare\n  \n\n\nThere must be a better way\n\n\nHow\n\n\nBy creating a tool that makes Auto layout code finally \nreadable by a human being\n.\n\nBy coupling it with live code injection such as \ninjectionForXcode\n we can \ndesign views in real time\n\nView layout becomes \nfun\n, \nconcise\n, \nmaintainable\n and dare I say, \nbeautiful\n \u2764\ufe0f\n\n\nWhat\n\n\n\n\n[x] Pure Swift Auto Layout DSL.\n\n\n[x] Simple: the apis are just NSLayoutConstraint shortcuts, pure UIKit code, no voodoo magic.\n\n\n\n\nAdvantages of Stevia\n\n\n\n\n[x] Improves the readability of Auto Layout in code.\n\n\n[x] Concise yet flexible apis.\n\n\n[x] Type-Safe Visual Format language.\n\n\n[x] Decribe Horizontal \n vertical layout at the same time.\n\n\n[x] Supports Live reload, for faster iteration cycles.\n\n\n[x] Styling is more concise, reusable and can be composed.\n\n\n\n\nLogin View Example\n\n\nIn the project folder, you can find an example of a typical login view laid out in both native and Stevia for you to understand and compare the two approaches.\n\n\nAs a spoiler alert, the \nnumber of characters\n goes from 2380 to 1239 \n( ~ divided by 2)\n\n\nWrite \nHalf the code\n that is actually \n10X more expressive and maintainable\n !\n\n\nContributors\n\n\nYannickDot\n,  \nS4cha\n,  \nDamien\n,\n\nSnowcraft\n, \nMathieu-o\n\n\nSwift Version\n\n\nSwift 2 -\n version \n2.3.0\n\nSwift 3 -\n version \n3.2.0\n\nSwift 4 -\n version \n4.0.0\n\n\nBackers\n\n\nLike the project? Offer coffee or support us with a monthly donation and help us continue our activities :)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSponsors\n\n\nBecome a sponsor and get your logo on our README on Github with a link to your site :)", 
            "title": "Overview"
        }, 
        {
            "location": "/#visual-layout-api", 
            "text": "layout ( \n     100 , \n     |- email -|   ~   80 , \n     8 , \n     |- password - forgot -|   ~   80 , \n     = 20 , \n     | login |   ~   80 , \n     0  )", 
            "title": "Visual Layout Api"
        }, 
        {
            "location": "/#chainable-api", 
            "text": "email . top ( 100 ). left ( 8 ). right ( 8 ). width ( 200 ). height ( 44 )  alignHorizontally ( password ,   forgot )  image . fillContainer ()  button . centerInContainer (). size ( 50 % )  equalWidths ( email ,   password )  image . width ( = 80 )", 
            "title": "Chainable Api"
        }, 
        {
            "location": "/#equation-based-api", 
            "text": "email . Top   ==   100  password . CenterY   ==   forgot . CenterY  login . Top   =   password . Bottom   +   20  login . Width   ==   75   %   Width   All Generate  native  NSLayoutConstraints \ud83c\udf89", 
            "title": "Equation-Based Api"
        }, 
        {
            "location": "/#try-it", 
            "text": "Stevia is part of  freshOS  iOS toolset. Try it in an example App !  Download Starter Project", 
            "title": "Try it!"
        }, 
        {
            "location": "/#reason", 
            "text": "", 
            "title": "Reason"
        }, 
        {
            "location": "/#why", 
            "text": "Because  nothing holds more truth than pure code  \ud83e\udd13 \nXibs and storyboards are  heavy, hard to maintain, hard to merge. \nThey split the view concept into 2 separate files making debugging a  nightmare     There must be a better way", 
            "title": "Why"
        }, 
        {
            "location": "/#how", 
            "text": "By creating a tool that makes Auto layout code finally  readable by a human being . \nBy coupling it with live code injection such as  injectionForXcode  we can  design views in real time \nView layout becomes  fun ,  concise ,  maintainable  and dare I say,  beautiful  \u2764\ufe0f", 
            "title": "How"
        }, 
        {
            "location": "/#what", 
            "text": "[x] Pure Swift Auto Layout DSL.  [x] Simple: the apis are just NSLayoutConstraint shortcuts, pure UIKit code, no voodoo magic.", 
            "title": "What"
        }, 
        {
            "location": "/#advantages-of-stevia", 
            "text": "[x] Improves the readability of Auto Layout in code.  [x] Concise yet flexible apis.  [x] Type-Safe Visual Format language.  [x] Decribe Horizontal   vertical layout at the same time.  [x] Supports Live reload, for faster iteration cycles.  [x] Styling is more concise, reusable and can be composed.", 
            "title": "Advantages of Stevia"
        }, 
        {
            "location": "/#login-view-example", 
            "text": "In the project folder, you can find an example of a typical login view laid out in both native and Stevia for you to understand and compare the two approaches.  As a spoiler alert, the  number of characters  goes from 2380 to 1239  ( ~ divided by 2)  Write  Half the code  that is actually  10X more expressive and maintainable  !", 
            "title": "Login View Example"
        }, 
        {
            "location": "/#contributors", 
            "text": "YannickDot ,   S4cha ,   Damien , Snowcraft ,  Mathieu-o", 
            "title": "Contributors"
        }, 
        {
            "location": "/#swift-version", 
            "text": "Swift 2 -  version  2.3.0 \nSwift 3 -  version  3.2.0 \nSwift 4 -  version  4.0.0", 
            "title": "Swift Version"
        }, 
        {
            "location": "/#backers", 
            "text": "Like the project? Offer coffee or support us with a monthly donation and help us continue our activities :)", 
            "title": "Backers"
        }, 
        {
            "location": "/#sponsors", 
            "text": "Become a sponsor and get your logo on our README on Github with a link to your site :)", 
            "title": "Sponsors"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nCocoaPods\n\n\npod\n \nSteviaLayout\n\n\nuse_frameworks\n!\n\n\n\n\n\n\nCarthage\n\n\ngithub\n \nfreshOS/Stevia\n\n\n\n\n\n\n\n\n\n\nCreate a \nCartfile\n file at the root of your project folder\n\n\n\n\n\n\nAdd \ngithub \"freshOS/Stevia\"\n to your Cartfile\n\n\n\n\n\n\nRun \ncarthage update\n\n\n\n\n\n\nDrag and drop \nStevia.framework\n from \n/Carthage/Build/iOS/\n to Linked frameworks and libraries in Xcode (Project\nTarget\nGeneral\nLinked frameworks and libraries)\n\n\n\n\n\n\nAdd new run script (Project\nTarget\nBuild Phases\n+\n New run script phase) \n/usr/local/bin/carthage copy-frameworks\n\n\n\n\n\n\nAdd Input files \n$(SRCROOT)/Carthage/Build/iOS/Stevia.framework\n\n\n\n\n\n\nThere you go!\n\n\nManual\n\n\nCopy Stevia source files to your Xcode project", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#cocoapods", 
            "text": "pod   SteviaLayout  use_frameworks !", 
            "title": "CocoaPods"
        }, 
        {
            "location": "/installation/#carthage", 
            "text": "github   freshOS/Stevia     Create a  Cartfile  file at the root of your project folder    Add  github \"freshOS/Stevia\"  to your Cartfile    Run  carthage update    Drag and drop  Stevia.framework  from  /Carthage/Build/iOS/  to Linked frameworks and libraries in Xcode (Project Target General Linked frameworks and libraries)    Add new run script (Project Target Build Phases +  New run script phase)  /usr/local/bin/carthage copy-frameworks    Add Input files  $(SRCROOT)/Carthage/Build/iOS/Stevia.framework    There you go!", 
            "title": "Carthage"
        }, 
        {
            "location": "/installation/#manual", 
            "text": "Copy Stevia source files to your Xcode project", 
            "title": "Manual"
        }, 
        {
            "location": "/viewHierarchy/", 
            "text": "sv\n(\n\n    \nsubview1\n,\n\n    \nsubview2\n,\n\n    \nsubview3\n\n\n)\n\n\n\n\n\n\nsv([])\n and \nsv()\n are essentially shortcuts that call \naddSubview()\n and\n\nview.translatesAutoresizingMaskIntoConstraints = false\n\n\nIt also has the benefit of being \nvery visual\n so that your can actually \nsee\n what the view hierarchy is.\nThis is especially true for nested hierarchies :\n\n\nsv\n(\n\n    \nsubview1\n,\n\n    \nsubview2\n.\nsv\n(\n\n        \nnestedView1\n,\n\n        \nnestedView2\n\u0328\n\n    \n),\n\n    \nsubview3\n\n\n)", 
            "title": "View Hierarchy"
        }, 
        {
            "location": "/Layout/sizing/", 
            "text": "Width\n\n\nview\n.\nwidth\n(\n100\n)\n\n\n\n\n\n\nHeight\n\n\nview\n.\nheight\n(\n100\n)\n\n\n\n\n\n\nSize\n\n\nview\n.\nsize\n(\n100\n)\n\n\n\n\n\n\nConstraining multiple views\n\n\nequalSizes\n(\nimage1\n,\n \nimage2\n,\n \nimage2\n)\n\n\nequalWidths\n(\nfield1\n,\n \nfield2\n,\n \nfield3\n,\n \nfield4\n)\n\n\nequalHeights\n(\nbutton1\n,\n \nbutton2\n)\n\n\n\n\n\n\nConstraining a view to stay squared\n\n\nview\n.\nheightEqualsWidth\n()", 
            "title": "Sizing"
        }, 
        {
            "location": "/Layout/centering/", 
            "text": "Horizontally\n\n\nimageView\n.\ncenterHorizontally\n()\n\n\nimageView\n.\ncenterHorizontally\n(\n20\n)\n \n//offset\n\n\n\n\n\n\nVertically\n\n\nimageView\n.\ncenterVertically\n()\n\n\nimageView\n.\ncenterVertically\n(\n20\n)\n \n//offset\n\n\n\n\n\n\nOn both axis\n\n\nimageView\n.\ncenterInContainer\n()", 
            "title": "Centering"
        }, 
        {
            "location": "/Layout/filling/", 
            "text": "Horizontally\n\n\nview\n.\nfillHorizontally\n()\n\n\nview\n.\nfillHorizontally\n(\nm\n:\n \n20\n)\n \n// padding\n\n\n\n\n\n\nVertically\n\n\nview\n.\nfillVertically\n()\n\n\nview\n.\nfillVertically\n(\nm\n:\n \n20\n)\n \n// padding\n\n\n\n\n\n\nAll container\n\n\nview\n.\nfillContainer\n()\n\n\nview\n.\nfillContainer\n(\n20\n)\n \n// Padding", 
            "title": "Filling"
        }, 
        {
            "location": "/Layout/aligning/", 
            "text": "Horizontally\n\n\nalignHorizontally\n(\navatar\n,\nname\n,\nfollowButton\n)\n\n\n\n\n\n\nVertically\n\n\nalignVertically\n(\ntitle\n,\nsubtitle\n,\ntext\n)\n\n\n\n\n\n\nTops\n\n\nalignTops\n(\ntitle\n,\nsubtitle\n,\ntext\n)\n\n\n\n\n\n\nBottoms\n\n\nalignBottoms\n(\ntitle\n,\nsubtitle\n,\ntext\n)\n\n\n\n\n\n\nRights\n\n\nalignRights\n(\ntitle\n,\nsubtitle\n,\ntext\n)\n\n\n\n\n\n\nLefts\n\n\nalignLefts\n(\ntitle\n,\nsubtitle\n,\ntext\n)\n\n\n\n\n\n\nAlign the center of one view with another one :\n\n\nalignCenter\n(\nview1\n,\n \nwith\n:\n \nview2\n)\n\n\n\n\n\n\nIn the example above of a follow Cell, here is how the layout code would look like :\n\n\n|-\navatar\n-\n15\n-\nname\n-\n20\n-\nfollowButton\n-|\n\n\nalignHorizontally\n(\navatar\n,\nname\n,\nfollowButton\n)\n\n\n\n\n\n\nBut \n|-avatar-15-name-20-followButton-|\n actually \nreturns the array of views!!!\n so we can write it in one \nsingle\n statement :\n\n\nalignHorizontally\n(\n|-\navatar\n-\n15\n-\nname\n-\n20\n-\nfollowButton\n-|\n)\n\n\n\n\n\n\n\ud83c\udf89\ud83c\udf89\ud83c\udf89", 
            "title": "Aligning"
        }, 
        {
            "location": "/Layout/following/", 
            "text": "The typical example of this is when we want to have a button on top of an image.\n\n\nbutton\n.\nfollowEdges\n(\nimageView\n)", 
            "title": "Following another View"
        }, 
        {
            "location": "/Layout/horizontal/", 
            "text": "This is intended to look like \nApple's visual format\n, so you should be very familiar with the syntax.\nStevia only removes the \n[]\n and the String.\n\n\nStick a label to the left of the screen\n\n\n|\nlabel\n\n\n\n\n\n\nWith the default margin (8)\n\n\n|-\nlabel\n\n\n\n\n\n\nWith a custom margin\n\n\n|-\n42\n-\nlabel\n\n\n\n\n\n\nJust to be very clear we want to \nemphasize\n that this is \npure syntactic sugar\n.\nThis equivalent of the following using the chainable api :\n\n\nlabel\n.\nleft\n(\n42\n)\n\n\n\n\n\n\nWhich in turn will create \nNative Autolayout constraints\n :\n\n\nlabel\n.\nsuperview\n?.\naddConstraint\n(\n\n  \nNSLayoutConstraint\n(\n\n    \nitem\n:\n \nlabel\n,\n\n    \nattribute\n:.\nLeft\n,\n\n    \nrelatedBy\n:\n \n.\nEqual\n,\n\n    \ntoItem\n:\n \nlabel\n.\nsuperview\n!,\n\n    \nattribute\n:.\nLeft\n,\n\n    \nmultiplier\n:\n \n1\n,\n\n    \nconstant\n:\n \n42\n\n  \n)\n\n\n)\n\n\n\n\n\n\nCombine all at once.\n\n\n|-\navatar\n-\n15\n-\nname\n-\n20\n-\nfollowButton\n-|", 
            "title": "Horizontal"
        }, 
        {
            "location": "/Layout/vertical/", 
            "text": "avatar\n.\ntop\n(\n50\n)\n\n\n\n\n\n\n==\n\n\nlayout\n(\n\n    \n50\n,\n\n    \navatar\n\n  \n)\n\n\n\n\n\n\nWhile using \nlayout\n for a single element might seem a bit overkill, it really \nshines\n when \ncombined with horizontal layout.\n\nThen we have the full \nlayout in one place\n (hence the name).\n\n\nlayout\n(\n\n    \n50\n,\n\n    \n|-\n15\n-\navatar\n.\nsize\n(\n60\n)\n\n  \n)\n\n\n\n\n\n\nThe avatar is 50px from the top with a left margin of 15px and a size of 60px\n\n\nAnother great example is the login view, representable in \none\n single statement !\n\n\nlayout\n(\n\n    \n100\n,\n\n    \n|-\nemail\n-|\n \n~\n \n80\n,\n\n    \n8\n,\n\n    \n|-\npassword\n-|\n \n~\n \n80\n,\n\n    \n,\n\n    \n|\nlogin\n|\n \n~\n \n80\n,\n\n    \n0\n\n\n)\n\n\n\n\n\n\nIn case you wonder \n~\n operator == \n.height(x)\n, it's just more readable in a layout statement that way.\n\n\nChainable Api\n\n\nThe avatar example above could've been written that way using the chainable api :\n\n\navatar\n.\ntop\n(\n50\n).\nleft\n(\n15\n).\nsize\n(\n50\n)\n\n\n\n\n\n\nUsing \nlayout\n is just clearer in most of the cases but it's yours to choose which way you prefer :)", 
            "title": "Vertical"
        }, 
        {
            "location": "/Layout/vertical/#chainable-api", 
            "text": "The avatar example above could've been written that way using the chainable api :  avatar . top ( 50 ). left ( 15 ). size ( 50 )   Using  layout  is just clearer in most of the cases but it's yours to choose which way you prefer :)", 
            "title": "Chainable Api"
        }, 
        {
            "location": "/Layout/flexibleMargins/", 
            "text": "Flexible margins can be used exactly like regular margins:\n\n\nWith chainable Api\n\n\nview\n.\ntop\n(\n=\n5\n)\n\n\nview\n.\nleft\n(\n=\n20\n)\n\n\nview\n.\nbottom\n(\n=\n10\n)\n\n\nview\n.\nright\n(\n=\n15\n)\n\n\nview\n.\nwidth\n(\n=\n45\n)\n\n\nview\n.\nheight\n(\n=\n100\n)\n\n\n\n\n\n\nIn layout calls\n\n\nlayout\n(\n\n    \n5\n,\n\n    \n|-\nlabel\n-\n(\n=\n5\n)\n-|\n,\n\n    \n=\n20\n,\n\n    \nseparator\n \n~\n \n(\n=\n10\n),\n\n    \n0\n\n\n)", 
            "title": "Flexible"
        }, 
        {
            "location": "/Layout/flexibleMargins/#with-chainable-api", 
            "text": "view . top ( = 5 )  view . left ( = 20 )  view . bottom ( = 10 )  view . right ( = 15 )  view . width ( = 45 )  view . height ( = 100 )", 
            "title": "With chainable Api"
        }, 
        {
            "location": "/Layout/flexibleMargins/#in-layout-calls", 
            "text": "layout ( \n     5 , \n     |- label - ( = 5 ) -| , \n     = 20 , \n     separator   ~   ( = 10 ), \n     0  )", 
            "title": "In layout calls"
        }, 
        {
            "location": "/Layout/percentage/", 
            "text": "view\n.\ntop\n(\n5\n%\n)\n\n\nview\n.\nleft\n(\n20\n%\n)\n\n\nview\n.\nbottom\n(\n10\n%\n)\n\n\nview\n.\nright\n(\n15\n%\n)\n\n\nview\n.\nwidth\n(\n45\n%\n)\n\n\nview\n.\nheight\n(\n100\n%\n)\n\n\nview\n.\nHeight\n \n==\n \n47\n \n%\n \nbutton\n.\nWidth", 
            "title": "Percentage"
        }, 
        {
            "location": "/Layout/equations/", 
            "text": "Tricky layout cases can be described as equations.\n\n\nbutton\n.\nCenterY\n \n==\n \navatar\n.\nBottom\n \n-\n \n4\n\n\nlabel\n.\nWidth\n \n=\n \nbutton\n.\nWidth\n \n*\n \n3\n\n\nlabel\n.\nHeight\n \n==\n \n(\nbutton\n.\nWidth\n \n/\n \n7\n)\n \n+\n \n3\n\n\nbutton\n.\nLeft\n \n=\n \nimage\n.\nRight\n \n-\n \n20\n\n\nimage\n.\nHeight\n \n=\n \n100\n\n\nview\n.\nTop\n \n==\n \n10\n\n\n\n\n\n\nThe result is a native NSLayoutConstraint. So you can modify priority like so :\n\n\n(\nlabel\n.\nWidth\n \n==\n \nbutton\n.\nWidth\n \n*\n \n3\n).\npriority\n \n=\n \n1000\n \n// Making this a required constraint.", 
            "title": "Equations"
        }, 
        {
            "location": "/Layout/priorities/", 
            "text": "There is no special Stevia api for priorities.\nIn order to set them, you need to use the good'ol standard api :)\nBy default, Stevia constraints are created with a priority of \n751\n.\n\n\nlet\n \nc\n \n=\n \nNSLayoutConstraint\n(\nitem\n:\n \nv\n,\n \nattribute\n:\n \n.\nTop\n,\n \nrelatedBy\n:\n \n.\nEqual\n,\n \ntoItem\n:\n \nv\n,\n \nattribute\n:\n \n.\nTop\n,\n \nmultiplier\n:\n \n1\n,\n \nconstant\n:\n \n0\n)\n\n\nc\n.\npriority\n \n=\n \n1000\n \n// Make a constraint `required`\n\n\naddConstraint\n(\nc\n)\n\n\n\n\n\n\n(\nlabel\n.\nWidth\n \n==\n \nbutton\n.\nWidth\n \n*\n \n3\n).\npriority\n \n=\n \n1000\n \n// Making this a required constraint.\n\n\n\nlet\n \nconstraint\n \n==\n \nview\n.\nHeight\n \n=\n \n50\n \n%\n \nHeight\n\n\n// later..\n\n\nconstraint\n.\npriority\n \n=\n \n750", 
            "title": "Priorities"
        }, 
        {
            "location": "/styling/", 
            "text": "Well, just call \nstyle\n on a UIView subclass :\n\n\nIn-line\n for small or unique styles\n\n\ndetail\n.\nstyle\n \n{\n \nl\n \nin\n\n  \nl\n.\nnumberOfLines\n \n=\n \n0\n\n  \nl\n.\ntextAlignment\n \n=\n \n.\nCenter\n\n  \nl\n.\ntextColor\n \n=\n \n.\nblueColor\n()\n\n  \nl\n.\ntext\n \n=\n \nNSLocalizedString\n(\nNeedPetMessage\n,\n \ncomment\n:\n \n)\n\n\n}\n\n\n\n\n\n\nOr in a separate to make them reusable\n\n\n// My style method, kinda like CSS\n\n\nfunc\n \ndetailStyle\n(\nl\n:\nUILabel\n)\n \n{\n\n  \nl\n.\nnumberOfLines\n \n=\n \n0\n\n  \nl\n.\ntextAlignment\n \n=\n \n.\nCenter\n\n  \nl\n.\ntextColor\n \n=\n \n.\nblueColor\n()\n\n  \nl\n.\ntext\n \n=\n \nNSLocalizedString\n(\nNeedPetMessage\n,\n \ncomment\n:\n \n)\n\n\n}\n\n\n\n// Later\n\n\n{\n\n  \n// Set my style\n\n  \ndetail\n.\nstyle\n(\ndetailStyle\n)\n\n\n}\n\n\n\n\n\n\nThis is the \npreferred\n way because the styles become \nreusable\n and \ncomposable\n: you can chain them!\nYou can even create a Style File grouping high level functions for common styles.\nUsage then becomes very similar to CSS!", 
            "title": "Styling"
        }, 
        {
            "location": "/changingConstraints/", 
            "text": "After laying out a view once, how do I change some constraints ?\n\n\nSimple Changes\n\n\n// Initial layout\n\n\nimage\n.\nheight\n(\n100\n)\n\n\n\n// And later on\n\n\nimage\n.\nheightConstraint\n?.\nconstant\n \n=\n \n200\n\n\n\n\n\n\nThose getters are available for \nleft\n, \nright\n, \ntop\n, \nbottom\n, \nheight\n and \nwidth\n constraints\n\n\nComplex changes\n\n\nWhen we want to change the whole layout at once then the best strategy is to\nflush \n relayout.\n\n\n// Initial layout\n\n\nlayout\n(\n\n    \n100\n,\n\n    \n|-\nemail\n-|\n,\n\n    \n8\n,\n\n    \n|-\npassword\n-|\n,\n\n\n)\n\n\n\n// Flush all view constraints\n\n\nremoveConstraints\n(\nconstraints\n)\n\n\n\n// Re-apply different layout\n\n\nlayout\n(\n\n     \n|-\npassword\n-|\n,\n\n     \n8\n,\n\n     \n|-\n44\n-\nemail\n-\n100\n-|\n,\n\n     \n10\n\n \n)\n\n\n\n\n\n\nAnimating Changes\n\n\nTo animate a constraint is to change the constant property on it and then call self.layoutIfNeeded() in an animation block.\n\n\nAnimating with stevia is no different than native Autolayout\n\n\nIn both cases, animating the constraint change is as easy as calling \nlayoutIfNeeded\n in an animation block.\n\n\nUIView\n.\nanimateWithDuration\n(\n2\n)\n \n{\n\n    \nself\n.\nlayoutIfNeeded\n()\n\n\n}", 
            "title": "Changing Constraints"
        }, 
        {
            "location": "/changingConstraints/#simple-changes", 
            "text": "// Initial layout  image . height ( 100 )  // And later on  image . heightConstraint ?. constant   =   200   Those getters are available for  left ,  right ,  top ,  bottom ,  height  and  width  constraints", 
            "title": "Simple Changes"
        }, 
        {
            "location": "/changingConstraints/#complex-changes", 
            "text": "When we want to change the whole layout at once then the best strategy is to\nflush   relayout.  // Initial layout  layout ( \n     100 , \n     |- email -| , \n     8 , \n     |- password -| ,  )  // Flush all view constraints  removeConstraints ( constraints )  // Re-apply different layout  layout ( \n      |- password -| , \n      8 , \n      |- 44 - email - 100 -| , \n      10 \n  )", 
            "title": "Complex changes"
        }, 
        {
            "location": "/changingConstraints/#animating-changes", 
            "text": "To animate a constraint is to change the constant property on it and then call self.layoutIfNeeded() in an animation block.  Animating with stevia is no different than native Autolayout  In both cases, animating the constraint change is as easy as calling  layoutIfNeeded  in an animation block.  UIView . animateWithDuration ( 2 )   { \n     self . layoutIfNeeded ()  }", 
            "title": "Animating Changes"
        }, 
        {
            "location": "/cells/", 
            "text": "For both tableView cells and UICollectionView cells, \nsv\n adds the subviews to the \ncontentView\n, as recommended.\n\n\nExample\n\n\nclass\n \nFriendCell\n:\n \nUITableViewCell\n \n{\n\n\n    \nlet\n \navatar\n \n=\n \nUIImageView\n()\n\n    \nlet\n \nname\n \n=\n \nUILabel\n()\n\n\n    \nrequired\n \ninit\n?(\ncoder\n \naDecoder\n:\n \nNSCoder\n)\n \n{\n \nsuper\n.\ninit\n(\ncoder\n:\n \naDecoder\n)}\n\n    \noverride\n \ninit\n(\nstyle\n:\n \nUITableViewCellStyle\n,\n \nreuseIdentifier\n:\n \nString\n?)\n \n{\n\n        \nsuper\n.\ninit\n(\nstyle\n:\n \nstyle\n,\n \nreuseIdentifier\n:\n \nreuseIdentifier\n)\n\n\n        \nsv\n(\n\n            \navatar\n,\n\n            \nname\n.\nstyle\n(\nnameStyle\n)\n\n        \n)\n\n\n        \navatar\n.\nsize\n(\n50\n).\ncenterVertically\n()\n\n        \nalignHorizontally\n(\n|-\n20\n-\navatar\n-\nname\n-\n20\n-|\n)\n\n    \n}\n\n\n    \nfunc\n \nnameStyle\n(\nl\n:\nUILabel\n)\n \n{\n\n        \nl\n.\nfont\n \n=\n \n.\nsystemFontOfSize\n(\n24\n)\n\n        \nl\n.\ntextColor\n \n=\n \n.\nblueColor\n()\n\n    \n}\n\n\n}\n\n\n\n\n\n\nThen in the viewController you do the usual \nregister\n and \ndequeue\n :)\n\n\n// In viewDidLoad, register your cell for dequeue\n\n\ntableView\n.\nregisterClass\n(\nFriendCell\n.\nself\n,\n \nforCellReuseIdentifier\n:\n \nFriendCell\n)\n\n\n\n// Later, in cellForRowAtIndexPath\n\n\nlet\n \ncell\n \n=\n \ntableView\n.\ndequeueReusableCellWithIdentifier\n(\nFriendCell\n,\n \nforIndexPath\n:\n \nindexPath\n)\n \nas\n!\n \nFriendCell", 
            "title": "TableView Cells & CollectionView Cells"
        }, 
        {
            "location": "/cells/#example", 
            "text": "class   FriendCell :   UITableViewCell   { \n\n     let   avatar   =   UIImageView () \n     let   name   =   UILabel () \n\n     required   init ?( coder   aDecoder :   NSCoder )   {   super . init ( coder :   aDecoder )} \n     override   init ( style :   UITableViewCellStyle ,   reuseIdentifier :   String ?)   { \n         super . init ( style :   style ,   reuseIdentifier :   reuseIdentifier ) \n\n         sv ( \n             avatar , \n             name . style ( nameStyle ) \n         ) \n\n         avatar . size ( 50 ). centerVertically () \n         alignHorizontally ( |- 20 - avatar - name - 20 -| ) \n     } \n\n     func   nameStyle ( l : UILabel )   { \n         l . font   =   . systemFontOfSize ( 24 ) \n         l . textColor   =   . blueColor () \n     }  }   Then in the viewController you do the usual  register  and  dequeue  :)  // In viewDidLoad, register your cell for dequeue  tableView . registerClass ( FriendCell . self ,   forCellReuseIdentifier :   FriendCell )  // Later, in cellForRowAtIndexPath  let   cell   =   tableView . dequeueReusableCellWithIdentifier ( FriendCell ,   forIndexPath :   indexPath )   as !   FriendCell", 
            "title": "Example"
        }, 
        {
            "location": "/viewFromController/", 
            "text": "Once again, this is not Stevia-related per se but since we're not generally used to writing views in code, then some explanation might be useful  \ud83e\udd13\n\n\nIt goes like this :\n\n- 1. Keeping a reference to our custom view.\n\n- 2. Loading our view instead of the bare default one by overriding \nloadView\n\n\nclass\n \nMyViewController\n:\n \nUIViewController\n \n{\n\n\n    \nlet\n \nmyCustomView\n \n=\n \nMyCustomView\n()\n \n// 1\n\n\n    \noverride\n \nfunc\n \nloadView\n()\n \n{\n \n// 2\n\n      \nview\n \n=\n \nmyCustomView\n\n    \n}\n\n\n    \noverride\n \nfunc\n \nviewDidLoad\n()\n \n{\n\n        \nsuper\n.\nviewDidLoad\n()\n\n        \nmyCustomView\n.\nloginButton\n.\naddTarget\n(\nself\n,\n \naction\n:\n \n#selector\n(\nlogin\n),\n \nfor\n:\n \n.\ntouchUpInside\n)\n\n    \n}\n\n\n    \n@objc\n\n    \nfunc\n \nlogin\n()\n \n{\n\n      \n// do something\n\n    \n}\n\n\n}", 
            "title": "Getting views from the controller"
        }, 
        {
            "location": "/nested/", 
            "text": "We believe complex nested views should be refactored into their own \nUIView\n subclasses.\n\n\nFor instance, if out App is using a form field multiple times, it is wise to extract it in its own UIView subclass like so:\n\n\nclass\n \nCustomField\n:\n \nUIView\n \n{\n\n\n    \nlet\n \nicon\n \n=\n \nUIImageView\n()\n\n    \nlet\n \nfield\n \n=\n \nUITextField\n()\n\n    \nlet\n \nimage\n \n=\n \nUIImageView\n()\n\n\n    \nconvenience\n \ninit\n()\n \n{\n\n        \nself\n.\ninit\n(\nframe\n:\nCGRect\n.\nzero\n)\n\n\n        \nsv\n(\n\n            \nicon\n,\n\n            \nfield\n,\n\n            \nimage\n\n        \n)\n\n\n        \nalignHorizontally\n(\n|-\nicon\n.\nsize\n(\n40\n).\ncenterVertically\n()\n-\nfield\n-\nimage\n.\nsize\n(\n40\n)\n-|\n)\n\n\n        \nbackgroundColor\n \n=\n \n.\nwhiteColor\n()\n\n        \nlayer\n.\ncornerRadius\n \n=\n \n5\n\n        \nlayer\n.\nshadowOffset\n \n=\n \nCGSize\n(\nwidth\n:\n \n2\n,\n \nheight\n:\n2\n)\n\n        \nlayer\n.\nshadowOpacity\n \n=\n \n0.5\n\n        \nicon\n.\nbackgroundColor\n \n=\n \n.\ngrayColor\n()\n\n        \nimage\n.\nbackgroundColor\n \n=\n \n.\nblackColor\n()\n\n    \n}\n\n\n}\n\n\n\n\n\n\nAnd then we can use it easily like so whenever we need it:\n\n\nclass\n \nLoginView\n:\n \nUIView\n \n{\n\n\n    \nlet\n \nusernameField\n \n=\n \nCustomField\n()\n\n    \nlet\n \npasswordField\n \n=\n \nCustomField\n()", 
            "title": "Complex nested layout"
        }, 
        {
            "location": "/knownIssues/", 
            "text": "Expression was to complex to be solved in reasonable time\n\n\n\"Expression was to complex to be solved in reasonable time\"\n can happen in Stevia, since the swift compiler has a hard time finding the right \n-\n operator overload. However it usually only happens with very long horizontal layouts with multiple margins.\n\n\nHere are three valid solutions for avoiding this annoying compiler error. All of them aim at making it easier for the compiler to find the right \n-\n operator version.\n\n\n// Solution 1\n\n\n// Putting margins in separate variables\n\n\nlet\n \nm\n:\nCGFloat\n \n=\n \n15\n\n\nlet\n \nm2\n:\nCGFloat\n \n=\n \n20\n\n\n|-\nm\n-\navatarImageView\n-\nm\n-\nuserNameLabel\n-\n-\nlikeButton\n-\nm2\n-|\n\n\n\n// Or Provide the type for margins to help the compiler\n\n\n|-\nCGFloat\n(\n15\n)\n-\navatarImageView\n-\nCGFloat\n(\n15\n)\n-\nuserNameLabel\n-\n-\nlikeButton\n-\nCGFloat\n(\n20\n)\n-|\n\n\n\n// Solution 2\n\n\n// Breaking it into smaller layouts\n\n\n|-\n15\n-\navatarImageView\n-\n15\n-\nuserNameLabel\n\n\nlikeButton\n-\n20\n-|\n\n\n\n// Solution 3\n\n\n// Using a double dash `--` version so that the compiler doesn\nt have to go through\n\n\n// all the existing `-` operator overloads defined by UIKit/Foundation\n\n\n|-\n15\n--\navatarImageView\n--\n15\n--\nuserNameLabel\n--\n--\nlikeButton\n--\n20\n-|", 
            "title": "Known Issues"
        }, 
        {
            "location": "/knownIssues/#expression-was-to-complex-to-be-solved-in-reasonable-time", 
            "text": "\"Expression was to complex to be solved in reasonable time\"  can happen in Stevia, since the swift compiler has a hard time finding the right  -  operator overload. However it usually only happens with very long horizontal layouts with multiple margins.  Here are three valid solutions for avoiding this annoying compiler error. All of them aim at making it easier for the compiler to find the right  -  operator version.  // Solution 1  // Putting margins in separate variables  let   m : CGFloat   =   15  let   m2 : CGFloat   =   20  |- m - avatarImageView - m - userNameLabel - - likeButton - m2 -|  // Or Provide the type for margins to help the compiler  |- CGFloat ( 15 ) - avatarImageView - CGFloat ( 15 ) - userNameLabel - - likeButton - CGFloat ( 20 ) -|  // Solution 2  // Breaking it into smaller layouts  |- 15 - avatarImageView - 15 - userNameLabel  likeButton - 20 -|  // Solution 3  // Using a double dash `--` version so that the compiler doesn t have to go through  // all the existing `-` operator overloads defined by UIKit/Foundation  |- 15 -- avatarImageView -- 15 -- userNameLabel -- -- likeButton -- 20 -|", 
            "title": "Expression was to complex to be solved in reasonable time"
        }, 
        {
            "location": "/liveReload/", 
            "text": "Live Reload\n\n\nYou can even enable \nlive reload\n during your development phase! \ud83c\udf89\ud83c\udf89\ud83c\udf89\n\n\nStevia + \nInjectionForXcode\n = \n3 (WhoNeedsReactNative??) \ud83d\ude80\n\n\n\n\nJust Cmd+S and you can dev live in the simulator !\n\n\n\n\nDownload \nInjectionForXcode\n.\n\n\nInstall it \n Launch it.\n\n\nRestart Xcode.\n\n\nClick on  \nInject Source\n once.\n\n\nEnable the \nFile Watcher\n so that Cmd+S triggers an injection.\n\n\n\n\nIn order to support \nlive reload\n with InjectionForXcode, we simply need to tell our ViewController to rebuild a view after an injection occured.\n\n\nin \nviewDidLoad()\n add :\n\n\non\n(\nINJECTION_BUNDLE_NOTIFICATION\n)\n \n{\n\n    \nself\n.\nview\n \n=\n \nMyView\n()\n\n\n}\n\n\n\n\n\n\nCurrently InjectionForXcode doesn't seem to swizzle \ninit\n methods for some reason. So we have to move our view code in another methods\n\n\nconvenience\n \ninit\n()\n \n{\n\n    \nself\n.\ninit\n(\nframe\n:\nCGRect\n.\nzero\n)\n\n    \n//View code\n\n\n}\n\n\n\n\n\n\nBecomes\n\n\nconvenience\n \ninit\n()\n \n{\n\n    \nself\n.\ninit\n(\nframe\n:\nCGRect\n.\nzero\n)\n\n    \nrender\n()\n\n\n}\n\n\n\nfunc\n \nrender\n()\n \n{\n\n  \n//View code\n\n\n}\n\n\n\n\n\n\nAnd Voila :)", 
            "title": "Live Reload"
        }, 
        {
            "location": "/liveReload/#live-reload", 
            "text": "You can even enable  live reload  during your development phase! \ud83c\udf89\ud83c\udf89\ud83c\udf89  Stevia +  InjectionForXcode  =  3 (WhoNeedsReactNative??) \ud83d\ude80   Just Cmd+S and you can dev live in the simulator !   Download  InjectionForXcode .  Install it   Launch it.  Restart Xcode.  Click on   Inject Source  once.  Enable the  File Watcher  so that Cmd+S triggers an injection.   In order to support  live reload  with InjectionForXcode, we simply need to tell our ViewController to rebuild a view after an injection occured.  in  viewDidLoad()  add :  on ( INJECTION_BUNDLE_NOTIFICATION )   { \n     self . view   =   MyView ()  }   Currently InjectionForXcode doesn't seem to swizzle  init  methods for some reason. So we have to move our view code in another methods  convenience   init ()   { \n     self . init ( frame : CGRect . zero ) \n     //View code  }   Becomes  convenience   init ()   { \n     self . init ( frame : CGRect . zero ) \n     render ()  }  func   render ()   { \n   //View code  }   And Voila :)", 
            "title": "Live Reload"
        }
    ]
}